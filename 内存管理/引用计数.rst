引用计数
=======
    :`reference counting <reference_counting.py>`_:
        - 当对象的引用计数减少为 **0** 时，意味着对象已经没有被使用，可以释放其所占内存
        :优点:
            - 简单
            :实时性: 处理回收内存的时间分摊到了平时

                    - 引用计数必须在每次分配和释放内存的时候加入管理引用计数的动作
                    - 任何内存，一旦没有指向它的引用，就会立即被回收
                    - 其他主流垃圾收集计数必须在某种特殊条件下（比如内存分配失败）才回收垃圾
        :缺点:
            :执行效率低:
                - ``维护引用计数的额外操作`` 与 ``内存分配、释放、引用赋值的次数`` 成正比
                - 相比其他主流垃圾回收机制（比如 ``标记-清除`` 、 ``停止-复制`` ），执行效率低
                    - 因为这些技术所带来的额外操作基本上只是与待回收的内存数量有关
            :循环引用_: 交叉引用、引用环


循环引用
--------
    - 一组对象相互引用

        .. code-block:: python

            a = []
            b = [a]
            a.append(b)
            print(a, getrefcount(a))  #: [[[...]]] 4
            print(b, getrefcount(b))  #: [[[...]]] 4
    - 一个对象自己引用自己，也能构成循环引用

        .. code-block:: python

            c = []
            c.append(c)               #: [[...]] 4
            print(c, getrefcount(c))
    - 只有 `容器 <容器.rst>`_ 才有循环引用问题


回收循环引用的对象
"""""""""""""""
    - 循环引用的每一个对象使用结束后，不再被任何外部对象所引用
        - 不会再有人使用这些对象
        - 但是这些对象的引用计数都不为 **0**
        - 这组对象所占用的内存空间，永远不会被回收释放
    - gc 模块使用 `标记-清除 + 分代回收 <垃圾回收.rst>`_ 可以自动清除循环引用的对象
    - 手动回收循环引用对象

        .. code-block:: python

            import gc
            gc.set_debug(gc.DEBUG_STATS)
            class Cls(object): pass
            x = 10
            c1 = Cls()
            c2 = Cls()
            c1.t = c2
            c2.t = c1
            print(gc.collect())  #: 106  #: 回收干扰对象
            del x
            print(gc.collect())  #: 0    #: 非循环引用，没有回收
            del c1
            print(gc.collect())  #: 0    #: 循环引用未解除，没有回收
            del c2
            print(gc.collect())  #: 4    #: 显式地回收循环引用对象（提前执行分代回收动作）
    :内存泄露风险:
        :带有显式 ``__del__`` 的对象:
            - 如果循环引用中，两个对象都定义了 ``__del__``
            - **gc** 模块不知道应该先调用哪个 ``__del__``
            - 为了安全起见， **gc** 模块会把对象放到 ``gc.garbage`` 中
            - 但是不会销毁 **unreachable** 对象
            - 从而造成内存泄漏
        :被一个生命周期特别长的对象所引用的对象:
