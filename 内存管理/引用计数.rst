:`引用计数 <reference_count.py>`_:
    - 当对象的引用计数减少为 **0** 时，意味着对象已经没有被使用，可以释放其所占内存
    :优点:
        - 简单
        :实时性:
            - 处理回收内存的时间分摊到了平时
                - 引用计数必须在每次分配和释放内存的时候加入管理引用计数的动作
                - 任何内存，一旦没有指向它的引用，就会立即被回收
                - 其他主流垃圾收集计数必须在某种特殊条件下（比如内存分配失败）才回收垃圾
    :缺点:
        - 执行效率低
            - ``维护引用计数的额外操作`` 与 ``内存分配、释放、引用赋值的次数`` 成正比
            - 相比其他主流垃圾回收机制（比如 ``标记-清除`` 、 ``停止-复制`` ），执行效率低
                - 因为这些技术所带来的额外操作基本上只是与待回收的内存数量有关
        - 循环引用_ ，导致内存泄露


容器对象
"""""""
    :所有能够引用其他对象的对象: ``list, set, tuple, dict, class, instance, ...``
    - 容器对象可以包含多个对象，指向各个元素对象的引用
        - 变量名本身也是对象（没有类型），也占有内存地址（内存引用的标示）
        - 容器对象的 **id** 指向变量名
    - 只有容器之间才可能形成循环引用


窗口对象
"""""""
    - 容器对象相对外层的对象，比如字符串所属的列表


循环引用
"""""""
    - 又叫 **交叉引用**
    - 一组对象相互引用，每一个对象的引用计数都不为 **0**
    - 然而这些对象实际上并没有被任何外部对象所引用
    - 这意味着不会再有人使用这组对象，应该被回收的这组对象所占用的内存空间，永远不会被释放
