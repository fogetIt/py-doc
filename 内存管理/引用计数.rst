引用计数
=======
    :`reference counting <reference_counting.py>`_:
        - 当对象的引用计数减少为 **0** 时，意味着对象已经没有被使用，可以释放其所占内存
        :优点:
            - 简单
            :实时性:
                - 处理回收内存的时间分摊到了平时
                    - 引用计数必须在每次分配和释放内存的时候加入管理引用计数的动作
                    - 任何内存，一旦没有指向它的引用，就会立即被回收
                    - 其他主流垃圾收集计数必须在某种特殊条件下（比如内存分配失败）才回收垃圾
        :缺点:
            - 执行效率低
                - ``维护引用计数的额外操作`` 与 ``内存分配、释放、引用赋值的次数`` 成正比
                - 相比其他主流垃圾回收机制（比如 ``标记-清除`` 、 ``停止-复制`` ），执行效率低
                    - 因为这些技术所带来的额外操作基本上只是与待回收的内存数量有关
            :循环引用_: 交叉引用、引用环


容器对象
--------
    :所有能够引用、包含其他对象的对象: ``list, set, tuple, dict, class, instance, ...``
    - 容器对象可以包含多个对象，指向各个元素对象的引用
        - 变量名本身也是对象（没有类型），也占有内存地址（内存引用的标示）
        - 容器对象的 **id** 指向变量名
    - 只有容器之间才可能形成 循环引用_


非容器对象
---------
    - 数字、字符串以及其它“原子”类型
    - 没有 ``copy()`` ，产生的都是原对象的引用


窗口对象
--------
    容器对象相对外层的对象，比如字符串所属的列表


循环引用
--------
    - 一组对象相互引用
    .. code-block:: python

        a = []
        b = [a]
        a.append(b)
        print(a, getrefcount(a))  #: [[[...]]] 4
        print(b, getrefcount(b))  #: [[[...]]] 4
    - 一个对象自己引用自己，也能构成循环引用
    .. code-block:: python

        c = []
        c.append(c)               #: [[...]] 4
        print(c, getrefcount(c))
    - 循环引用的每一个对象使用结束后，不再被任何外部对象所引用
        - 不会再有人使用这些对象
        - 但是这些对象的引用计数都不为 **0**
        - 这组对象所占用的内存空间，永远不会被回收释放
    - gc 模块使用 `标记-清除 + 分代回收 <垃圾回收.rst>`_ 可以自动清除循环引用的对象
    - 手动回收循环引用对象
    .. code-block:: python

        import gc
        gc.set_debug(gc.DEBUG_STATS)
        class Cls(object): pass
        x = 10
        c1 = Cls()
        c2 = Cls()
        c1.t = c2
        c2.t = c1
        print(gc.collect())  #: 106  #: 回收干扰对象
        del x
        print(gc.collect())  #: 0    #: 非循环引用，没有回收
        del c1
        print(gc.collect())  #: 0    #: 循环引用未解除，没有回收
        del c2
        print(gc.collect())  #: 4    #: 显式地回收循环引用对象（提前执行分代回收动作）
    :内存泄露风险:
        - 带有显式 ``__del__`` 的对象
        ::
            如果循环引用中，两个对象都定义了 __del__
            gc 模块不知道应该先调用哪个 __del__
            为了安全起见， gc 模块会把对象放到 gc.garbage 中
            但是不会销毁 unreachable 对象
            从而造成内存泄漏
        - 对象被另一个生命周期特别长的对象所引用
