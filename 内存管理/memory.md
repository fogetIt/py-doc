### 内存管理，决定语言性能的重要因素
- 手工管理：C语言
- 垃圾回收：Java、Python

Python作为一种动态类型的语言，其对象和引用分离。
##### `Python`垃圾回收
- `引用计数（reference counting）`
    + 一种最直观，最简单的垃圾收集机制
    + `gc`模块主要运用了`引用计数`来跟踪和回收垃圾，管理大多数对象的`生命周期`
        * 引用计数`+1`
            - 对象被创建
            - 对象被引用
            - 对象作为一个元素，存储在容器中
            - 本地引用（对象作为参数或局部变量，传入到一个函数中）
                + 当一个引用传递给函数时，函数自动复制一份引用，函数里的引用和外边没有关系
        * 引用计数`-1`
            - 本地引用（如函数）结束
            - del 对象的引用
            - 对象的引用被重新赋值
            - del 对象
            - del 窗口对象（比如字符串所属的列表）
            - 对象被从一个窗口对象移除
        * 引用计数`归 0`
            - 重新赋值，引用计数归 0 、置为 1
    + 当对象的引用计数减少为`0`时，意味着对象已经没有被使用，可以将其所占用的内存释放
    + 优点
        * 简单
        * 实时性，处理回收内存的时间分摊到了平时
            - 虽然引用计数必须在每次分配和释放内存的时候加入管理引用计数的动作
            - 然而任何内存，一旦没有指向它的引用，就会立即被回收
            - 而其他主流的垃圾收集计数必须在某种特殊条件下（比如内存分配失败）才能进行无效内存的回收
    + 缺点
        * 引用计数机制的执行效率问题
            - 引用计数机制`维护引用计数的额外操作`与`python`运行中所进行的`内存分配和释放、引用赋值的次数`成正比
            - 而这点相比其他主流的垃圾回收机制，比如`标记-清除`、`停止-复制`，是一个弱点，因为这些技术所带来的额外操作基本上只是与待回收的内存数量有关
        * 循环引用（交叉引用），可能导致内存泄露
            - 一组对象相互引用，每一个对象的引用计数都不为`0`
            - 然而这些对象实际上并没有被任何外部对象所引用
            - 这意味着不会再有人使用这组对象，应该被回收的这组对象所占用的内存空间，永远不会被释放
- `标记-清除（mark and sweep）`
    + 解决容器对象可能产生的`循环引用`的问题
    + 只有容器对象（list,set,tuple,dict,class,instances）才会存在循环引用问题
        1. python内存管理模块使用双向链表（可收集对象链表）串联起容器对象，并为它们添加一个新的计数：gc_refs
            + 不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本
            + 对于副本做任何的改动，都不会影响到对象生命周期的维护
        2. 设置双向链表中所有对象的gc_refs（outer）初始值为其引用计数值
        3. 把每个对象中引用的对象的gc_refs（inner）值`-1`
        4. 遍历双向链表
            + 双向链表一分为二
            + 一条维护`root object`集合，成为`root`链表
                * root object集合————存储全局引用和函数栈上的引用，不能被回收
                * 把gc_refs>1的对象添加进`root object集合`中，标记为reachable
            + 另外一条链表中维护剩下的对象，成为unreachable链表
        5. 遍历`root object集合`
            + 在unreachable链表中找到被root链表中对象直接或间接引用的对象，将其从unreachable链表中移到root链表中，标记为reachable
        6. unreachable链表中剩余的对象就是unreachable对象，垃圾回收只需限制在unreachable链表中
- `分代回收（generation collection）`
    + 建立在标记清除基础上
    + 以空间换时间，提高垃圾收集的效率
    + `标记-清除`机制所带来的额外操作与`系统中总的内存块的数量`是相关的。当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外操作；
    + 一系列的研究表明：无论使用何种语言开发的何种类型、何种规模的程序，都存在这样一点相同之处————一定比例的内存块的生存周期都比较短，通常是几百万条机器指令的时间，而剩下的内存块，起生存周期比较长，甚至会从程序开始一直持续到程序结束；
        * 根据对象的存活时间将其内存块划分为3个不同的集合（代）————年轻代、中年代、老年代，对应3个链表；
        * 链表的垃圾收集频率随着对象的存活时间的增大而减小；
        * 新创建的对象分配在年轻代；
        * 年轻代链表的总数达到上限时，触发垃圾收集机制，回收掉那些可以被回收的对象，不会被回收的对象被移到中年代去，依此类推；
        * 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内；
- 垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。
    + 触发Python垃圾回收机制的特定条件
        * 调用gc.collect()
        * 当gc模块的计数器达到阀值的时候
            - 当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。
        * 程序退出的时候

##### `del`能直接释放内存

##### id(object) -> integer
- 返回十进制内存地址
- 十六进制内存地址
    + hex(id(object)) -> string
- is
    + 比较两个变量（变量名引用的对象）的内存地址
- `python`会缓存整数(-5~256)和短小的字符，以便重复使用
