垃圾回收
=======
- 触发条件
    - 显式地调用 ``gc.collect()``
    - `gc.get_count() 计数器达到 gc.get_threshold() 阀值 <gc.rst>`_
    - 程序退出的时候


标记-清除
--------
:mark and sweep: 解决 `容器对象 <容器.rst>`_ 可能产生的 `循环引用 <引用计数.rst>`_ 问题

    1. 使用 **可收集对象链表** （双向链表） 串联起 **容器对象**
        - 每次实例化容器对象时都将加入这个链表
    #. 遍历双向链表
        1. 给 **每个对象** 设置 ``gc.gc_refs`` 等于 ``ob_refcnt`` （引用计数值）
            - 不改动 ``ob_refcnt``
            - 对 ``gc.gc_refs`` 做任何改动，都不会影响到对象生命周期的维护
        #. 双向链表一分为二
            :``reachable``:   `root object`_
            :``unreachable``: 可被回收的对象
            #. 遍历容器对象引用的对象
                1. 被引用对象的引用计数都 **-1**
                #. ``gc.gc_refs > 1`` ，移动到 ``reachable``
                #. ``gc.gc_refs = 0`` ，移动到 ``unreachable``
            #. 将 ``reachable`` 对象放入下一代的 **可收集对象链表** 中
            #. 回收 ``unreachable`` 中剩余的真正的垃圾对象


分代回收
-------
**一系列的研究表明：**
        无论使用何种语言开发的何种类型、何种规模的程序，都存在这样一点相同之处：
            一定比例的内存块，生存周期比较短，通常是几百万条机器指令的时间
            剩下的内存块，生存周期比较长，甚至会从程序开始一直持续到程序结束
:generation collection: 在 **标记-清除** 基础上，以空间换时间，提高垃圾收集的效率

    - **标记-清除** 机制所带来的额外操作与 **系统中总的内存块的数量** 相关
        =================  ==========================  =====================
        需要回收的内存块       垃圾检测带来的额外操作          垃圾回收带来的额外操作
        =================  ==========================  =====================
        越多                 越多                         越少
        越少                 越少                         越多
        =================  ==========================  =====================
        - 垃圾回收时， **python** 不能进行其它的任务
        - 频繁的垃圾回收将大大降低 **python** 的工作效率
        - 如果内存中的对象不多，就没有必要总启动垃圾回收
    - 根据对象的存活时间将其内存块划分为 **3** 代，对应 **3** 个链表
        - 链表的垃圾收集频率随着对象的存活时间的增大而减小
            - 年轻代存储新创建的对象
            - 年轻代链表的总数达到上限时，触发垃圾收集机制，回收掉那些可以被回收的对象，不会被回收的对象被移到中年代去
            - 老年代依此类推，存放着存活时间最久的对象


root object
------------
全局和函数栈上引用的不可回收的容器对象


`参考 <http://www.wklken.me/posts/2015/09/29/python-source-gc.html>`_
