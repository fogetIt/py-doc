垃圾回收
=======
    - 触发条件
        - 显式地调用 ``gc.collect()``
        - `gc.get_count() 计数器达到 gc.get_threshold() 阀值 <gc.rst>`_
        - 程序退出的时候


标记-清除
--------
    :mark and sweep:
        - 解决 `容器对象 <容器.rst>`_ 可能产生的 `循环引用 <引用计数.rst>`_ 问题
            1. 使用 **可收集对象链表** （双向链表） 串联起 **容器对象**
                - 每次实例化容器对象时都将加入这个链表
            #. 遍历双向链表
                1. 给 **每个对象** 设置 ``gc.gc_refs`` 等于 ``ob_refcnt`` （引用计数值）
                    - 不改动 ``ob_refcnt``
                    - 对 ``gc.gc_refs`` 做任何改动，都不会影响到对象生命周期的维护
                #. 双向链表一分为二
                    :``reachable``:   `root object`_
                    :``unreachable``: 可被回收的对象
                    #. 遍历容器对象引用的对象
                        1. 被引用对象的引用计数都 **-1**
                        #. ``gc.gc_refs > 1`` ，移动到 ``reachable``
                        #. ``gc.gc_refs = 0`` ，移动到 ``unreachable``
                    #. 将 ``reachable`` 对象放入下一代的 **可收集对象链表** 中
                    #. 回收 ``unreachable`` 中剩余的真正的垃圾对象


分代回收
-------
    **一系列的研究表明：**
            无论使用何种语言开发的何种类型、何种规模的程序，都存在这样一点相同之处：
                一定比例的内存块，生存周期比较短，通常是几百万条机器指令的时间
                剩下的内存块，生存周期比较长，甚至会从程序开始一直持续到程序结束
    :generation collection: 在 **标记-清除** 基础上，以空间换时间，提高垃圾收集的效率

        - **标记-清除** 机制所带来的额外操作与 **系统中总的内存块的数量** 相关
            =================  ==========================  =====================
            需要回收的内存块       垃圾检测带来的额外操作          垃圾回收带来的额外操作
            =================  ==========================  =====================
            越多                 越多                         越少
            越少                 越少                         越多
            =================  ==========================  =====================
            - 垃圾回收时， **python** 不能进行其它的任务
            - 频繁的垃圾回收将大大降低 **python** 的工作效率
            - 如果内存中的对象不多，就没有必要总启动垃圾回收
        - 根据对象的存活时间将其内存块划分为 **3** 代，对应 **3** 个链表
            - 链表的垃圾收集频率随着对象的存活时间的增大而减小
                - 年轻代存储新创建的对象
                - 年轻代链表的总数达到上限时，触发垃圾收集机制，回收掉那些可以被回收的对象，不会被回收的对象被移到中年代去
                - 老年代依此类推，存放着存活时间最久的对象


root object
------------
    全局和函数栈上引用的不可回收的容器对象


`参考 <http://www.wklken.me/posts/2015/09/29/python-source-gc.html>`_
