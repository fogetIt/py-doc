垃圾回收
=======
    :标记-清除:
        - 解决 容器对象_ 可能产生的 循环引用_ 的问题
            1. `gc 模块`_ 使用 双向链表（零代链表）串联起容器对象，并为它们添加一个新的计数 ``gc_refs``
                - 不改动真实的引用计数，而是将链表中对象的引用计数复制一份副本
                - 对副本做任何的改动，都不会影响到对象生命周期的维护
            #. 设置双向链表中 **所有对象** 的 ``gc_refs(outer)`` 初始值为其引用计数值
            #. 设置双向链表中 **每个对象引用的对象** 的 ``gc_refs(inner)`` 值为 ``-1``
            #. 遍历双向链表
                - 双向链表一分为二
                    :``reachable``:
                        - 维护 ``gc_refs>1`` 的 ``root object``
                        - 存储全局引用和函数栈上的引用，不能被回收
                    :``unreachable``:
                        - 维护剩下的对象
            #. 遍历 ``reachable``
                - 在 ``unreachable`` 中找到被 ``reachable`` 中对象直接或间接引用的对象，移到 ``reachable`` 中
            #. 垃圾回收只需限制 ``unreachable`` 中剩余的对象
    - `分代回收（generation collection）`
        + 建立在标记清除基础上
        + 以空间换时间，提高垃圾收集的效率
        + `标记-清除`机制所带来的额外操作与`系统中总的内存块的数量`是相关的。当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额外操作；
        + 一系列的研究表明：无论使用何种语言开发的何种类型、何种规模的程序，都存在这样一点相同之处————一定比例的内存块的生存周期都比较短，通常是几百万条机器指令的时间，而剩下的内存块，起生存周期比较长，甚至会从程序开始一直持续到程序结束；
            * 根据对象的存活时间将其内存块划分为3个不同的集合（代）————年轻代、中年代、老年代，对应3个链表；
            * 链表的垃圾收集频率随着对象的存活时间的增大而减小；
            * 新创建的对象分配在年轻代；
            * 年轻代链表的总数达到上限时，触发垃圾收集机制，回收掉那些可以被回收的对象，不会被回收的对象被移到中年代去，依此类推；
            * 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内；
    - 垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。
        + 触发Python垃圾回收机制的特定条件
            * 调用gc.collect()
            * 当gc模块的计数器达到阀值的时候
                - 当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才会启动。
            * 程序退出的时候


带有显式 ``__del__`` 方法的对象需要手动释放循环引用
---------------------------------------------
    - **python** 自动 **gc** 在一般情况下也可以清除循环引用的对象
    - 当一个对象显式定义了 ``__del__`` ，而且里面有循环引用
        - **python** 不会自动回收这个对象
        - 如果这种情况没有正确处理，会造成内存泄漏

