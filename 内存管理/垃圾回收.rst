垃圾回收
=======


标记-清除
--------
    :mark and sweep:
        - 解决 容器对象_ 可能产生的 循环引用_ 问题
            1. **gc** 模块使用 双向链表串联起 **容器对象**
            #. 给双向链表中的 **所有对象** 复制一份引用计数 ``ob_refcnt`` 的副本 ``gc_refs(outer)``
                - 不改动对象的真实引用计数，对副本做任何的改动，都不会影响到对象生命周期的维护
            #. 设置双向链表中 **每个对象引用的对象** 的 ``gc_refs(inner)`` 值为 ``-1``
            #. 遍历双向链表
                - 双向链表一分为二
                    :``reachable``:
                        - 不可被回收的、 ``root object`` 对象
                            - ``gc_refs>1``
                            - 存储全局引用和函数栈上的引用，不能被回收
                    :``unreachable``: 剩下的、可被回收的对象的对象
            #. 遍历 ``reachable``
                - 在 ``unreachable`` 中找到被 ``reachable`` 中对象直接或间接引用的对象，移到 ``reachable`` 中
            #. 回收 ``unreachable`` 中剩余的对象


分代回收
-------
    :generation collection:
        - 在标记清除基础上，以空间换时间，提高垃圾收集的效率
            - **标记-清除** 机制所带来的额外操作与 **系统中总的内存块的数量** 相关
                =================  ==========================  =====================
                需要回收的内存块       垃圾检测带来的额外操作          垃圾回收带来的额外操作
                =================  ==========================  =====================
                越多                 越多                         越少
                越少                 越少                         越多
                =================  ==========================  =====================
                - 垃圾回收时， **python** 不能进行其它的任务
                - 频繁的垃圾回收将大大降低 **python** 的工作效率
                - 如果内存中的对象不多，就没有必要总启动垃圾回收
            - 一系列的研究表明：
                - 无论使用何种语言开发的何种类型、何种规模的程序，都存在这样一点相同之处：
                    - 一定比例的内存块，生存周期都比较短，通常是几百万条机器指令的时间
                    - 而剩下的内存块，生存周期比较长，甚至会从程序开始一直持续到程序结束
            - 根据对象的存活时间将其内存块划分为 **3** 个不同的集合（代），对应 **3** 个链表
                - 链表的垃圾收集频率随着对象的存活时间的增大而减小
                    - 年轻代存储新创建的对象
                    - 年轻代链表的总数达到上限时，触发垃圾收集机制，回收掉那些可以被回收的对象，不会被回收的对象被移到中年代去
                    - 老年代依此类推，存放着存活时间最久的对象
            - 垃圾回收机制的触发条件
                - 显式地调用 ``gc.collect()``
                - `gc.get_count() 计数器达到 gc.get_threshold() 阀值 <gc.rst>`_
                - 程序退出的时候


root object
------------
    全局和函数栈上引用的不可回收的容器对象

