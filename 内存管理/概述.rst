内存管理，决定语言性能的重要因素
===========================
    :手工管理: C
    :垃圾回收: Java, Python


python 作为一种动态类型的语言，其对象和引用分离。
------------------------------------------


id(object) -> integer
"""""""""""""""""""""
    - 返回 **10** 进制内存地址
    :``hex(id(object)) -> string``: 返回 **16** 进制内存地址


is
""
    - 比较两个变量（变量名引用的对象）的内存地址


内存池
"""""
    - **python** 会缓存整数 (-5~256) 和短小的字符，以便重复使用


循环引用
"""""""
    - 又叫 **交叉引用**
        - 一组对象相互引用，每一个对象的引用计数都不为 **0**
        - 然而这些对象实际上并没有被任何外部对象所引用
        - 这意味着不会再有人使用这组对象，这组对象所占用的内存空间，永远不会被回收释放
    :解决方法:
        - 标记-清除
        :P.S.:
            - 如果循环引用中，两个对象都定义了 ``__del__`` ， **gc** 模块不会销毁这些 ``unreachable`` 对象
                - 因为 **gc** 模块不知道应该先调用哪个 ``__del__``
                - 所以为了安全起见， **gc** 模块会把对象放到 ``gc.garbage`` 中，但是不会销毁对象


栈溢出
"""""
    - 函数调用是通过栈（ **stack** ）数据结构实现的
    - 系统为每一层递归调用的返回点、局部变量等开辟了栈来存储
        - 每当进入一个函数调用，栈就会加一层栈帧
        - 每当函数返回，栈就会减一层栈帧
    - 由于栈的大小不是无限的，所以，递归调用的次数过多，会导致 **栈溢出**
    - 所以一般不提倡用递归算法设计程序
