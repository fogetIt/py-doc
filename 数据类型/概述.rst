数据类型
#######
    ===========  ===========  ===========  ===========
    types          分类          结构         `可变？`_
    ===========  ===========  ===========  ===========
    ``dict``       容器类型      映射结构      ``dict.__hash__ is None``
    ``list``       容器类型      序列结构      ``list.__hash__ is None``
    ``set``        容器类型      序列结构      ``set.__hash__ is None``
    ``tuple``      容器类型      序列结构      ``hash()``
    ``str``        简单类型      序列结构      ``hash()``
    ``int``        简单类型                   ``hash()``
    ``float``      简单类型                   ``hash()``
    ``long``       简单类型                   ``hash()``
    ``complex``    简单类型                   ``hash()``
    ===========  ===========  ===========  ===========

.. _`可变？`:

:可变类型:
    - 支持索引赋值、删除
    - 对数据结构进行操作 会改变 原数据结构
:不可变类型:
    - 不支持索引赋值、删除
    - 对数据结构进行操作 **不会改变** 原数据结构
    - 不可变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误
    - 由于对象不可变，多任务环境下同时读取对象不需要加锁
    - 编程时，如果可以设计一个不可变对象，那就尽量设计成不可变对象


warn
    - **list** 内嵌套的 **tuple** ，不能通过索引赋值、删除
    - **tuple** 内嵌套的 **list, dict** ，可以通过索引赋值、删除


转化
----
    .. code-block:: python

        src = 'hello'

        l1 = [src]
        l2 = list(a)
        l1, len(l1) # (['hello'], 1)
        l2, len(l2) # (['h', 'e', 'l', 'l', 'o'], 5)

        (src) == src

        t1 = (src, )
        t2 = tuple(src)
        t1, len(t1) # (('hello',), 1)
        t2, len(t2) # (('h', 'e', 'l', 'l', 'o'), 5)

        s1 = {src}
        s2 = set(src)
        s1, len(s1) # ({'hello'}, 1)
        s2, len(s2) # ({'e', 'h', 'l', 'o'}, 4)


时间复杂度
---------
    :list:
        + 优点：占用空间小，浪费内存很少
        + 缺点：**list** 越长，耗时越长
            * 从第一个往后，直到找到想要的为止
    :dict:
        + 优点：无论数据多大，查找速度都不会变慢
            * 在字典的索引表里查 **str** 对应的键，然后直接找到值
        + 缺点：需要占用大量的内存，内存浪费多
            * **key-value** 存储方式，存放时必须根据 **key** 算出 **value** 的存放位置
            * **key** ，不可变对象，可哈希，长度固定
                - 一个 **key** 只能对应一个 **value**
                - 所以，多次对一个 **key** 设置 **value** ，后面的值会把前面的值冲掉
                - **dict** 内部存放的顺序和 **key** 放入的顺序没有关系