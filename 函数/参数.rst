参数
====
    - 不能链式赋值
    - 不能序列解包赋值

    :形参:
        - 函数（类）定义时的参数
    :实参:
        - 函数（类）调用时的参数

    **实参给形参赋值**
        - 无论形参、实参，位置参数在前，关键字参数在后
        - 实参给形参赋值顺序：从左到右，每个形参只被满足 **1** 次，重复满足，报错
        .. code-block:: python

            def demo(a, b="b", *args, **kwargs):
                print(a, b, args, kwargs)
            demo()                       # TypeError                    # 位置参数必须满足
            demo(b="b1")                 # TypeError                    # 位置参数必须满足
            demo("a")                    # ('a', 'b', (), {})
            demo(a="a")                  # ('a', 'b', (), {})           # 关键字参数 ->（传参时修改参数类型） 位置参数
            demo("a", "b1")              # ('a', 'b1', (), {})          # 位置参数 ->（传参时修改参数类型） 关键字参数
            demo("a", b="b1")            # ('a', 'b1', (), {})
            demo(b="b1", "a")            # SyntaxError                  # 位置参数在前，关键字参数在后（不满足）
            demo(b="b1", a="a")          # ('a', 'b1', (), {})          # 关键字参数 ->（传参时修改参数类型） 位置参数（实参关键字参数，不分先后）
            demo("a", "b1", b="b2")      # TypeError                    # 参数过剩（重复满足）
            demo("a", "b1", "b2")        # ('a', 'b1', ('b2',), {})     # 可变参数 ->（自动组装“剩余的值”） tuple
            demo("a", "b1", c="b2")      # ('a', 'b1', (), {'c': 'b2'}) # 可变参数 ->（自动组装“剩余的键值对”） dict
            demo("a", "b1", "b2", c="c") # ('a', 'b1', ('b2',), {'c': 'c'})


    **命名关键字参数**
        - 限制关键字参数的名字
        - 适用于 **python3**
        .. code-block:: python

            def demo(a, b, *, c, d):
                """
                * 后面的参数被视为命名关键字参数
                """
                print(a, b, c, d)
            demo(1, 2, 3, 4)      # TypeError
            demo(1, 2)            # TypeError
            demo(1, 2, c=3, d=4)  # 1 2 3 4


类的参数
=======
    - 实例化时，调用 **__init__()** ，按照 **__init__()** 定义传参
    - 通过类或实例对象调用函数时，按照函数定义传参


可变对象作参数
=============
函数通过引用调用参数（只复制变量的第一层引用）
--------------------------------------
    .. code-block:: python

        def change(arg):
            if type(arg) is list:
                """
                在函数中对“可变对象参数”的改变，“会”影响到原始的对象
                """
                arg.append('n')
            if type(arg) is int:
                """
                在函数中对“不可变对象参数”的改变，“不会”影响到原始的对象
                """
                arg += 1
            print(arg)
        a , b = 10, []
        change(a)   # 11
        change(b)   # ['n']
        print(a, b) # (10, ['n'])


函数的默认参数，仅仅在定义的时候，赋值一次
------------------------------------
    .. code-block:: python

        def add(arg, l=[]):
            """
            默认参数为可变类型（ list/dict ）时，参数会在原地更改
            """
            l.append(arg)
            print(l)
        add(10)     # [10]
        add(10)     # [10, 10]
        add(10, []) # [10]
        add(10, []) # [10]


        def add(arg, l=None):
            """
            使用不可变对象（ None/tuple ）来替换可变默认参数
            """
            l = l if l else []
            l.append(arg)
            print(l)
        # class __init__() 如果只在实例化时调用一次，可以使用可变类型作为默认参数
