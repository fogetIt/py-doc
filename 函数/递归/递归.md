### 递归
1. 自身调用自身
2. 有出口————递归结束边界条件：
    + 当边界条件不满足时，递归前进；
    + 当边界条件满足时（在问题的规模极小时必须用直接给出解答而不再进行递归调用），递归返回；
    + 无边界条件的递归调用将会成为死循环而不能正常结束；
3. 它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求
4. 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量
5. 递归算法通常很简洁，但运行效率（相对常用的算法如普通循环等）较低
6. 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。

递归对于对象的定义是按照“先前定义的”同类对象来定义的。例如：你怎样才能移动100个箱子？答案：你首先移动一个箱子，并记下它移动到的位置，然后再去解决较小的问题：你怎样才能移动99个箱子？最终，你的问题将变为怎样移动一个箱子，而这是你已经知道该怎么做的。

如此的定义在数学中十分常见。例如，集合论对自然数的正式定义是：1是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。

- 德罗斯特效应
- 汉诺塔
- 64格的麦粒

- 定义简单，逻辑清晰
- 函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。

### 尾递归————在函数返回的时候，调用自身本身。并且，return语句不能包含表达式。
这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化。