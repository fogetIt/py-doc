作用域
======
    - 变量（标识符）起作用的范围（所处的命名空间）
    :赋值: 产生标识符

        :显式赋值:
            - 直接赋值
            - 链式赋值
            - 序列解包赋值
        :隐式赋值:
            - 模块导入
            - 函数和类的定义
            - 循环变量
            - 函数参数
        - 赋值的地点决定标识符作用域
    :定义函数: 产生新的作用域


标识符的搜索顺序
--------------
    - ``L(local) ---> E(enclosing function) ---> G(global) ---> B(builtin)``
    :`L`: 局部作用域

        - 在一个函数中，而且这个函数里没有再包含函数
    :`E`: 嵌套作用域

        - 在一个函数中，但这个函数里面还包含有函数定义
        - L 层和 E 层只是相对的
    :`G`: 全局作用域
    :`B`: 内建作用域

        - 在解释器启动时就自动载入 **__builtin__** 模块（包含 **list(),str()** 等内置函数）


函数内部无法给外部的对象赋值
------------------------
    - 在某个作用域内为变量赋值时，变量被解释器自动视作该作用域的本地变量
    .. code-block:: python

        i1, l1 = 0, [0]
        def outer():
            i2, l2 = 0, [0]
            def inner():
                print(i1, i2)      #: 0 0                #: 外部不可变对象，直接访问
                # i1 += 1          #: UnboundLocalError  #: 外部不可变对象，无法重新赋值、绑定作用域
                # i2 += 1          #: UnboundLocalError
                print(l1, l2)      #: [0] [0]            #: 外部可变对象，直接访问
                l1[0] += 1
                l2.append(123)
                print(l1, l2)      #: [1] [0, 123]       #: 外部可变对象，直接修改
                # l1 += [1]        #: UnboundLocalError  #: 外部可变对象，无法重新赋值、绑定作用域
            print(i1, i2, l1, l2)  #: 0 0 [0] [0]        #: 最先执行
            return inner
        outer()()
        print(i1, l1)              #: 0 [1]              #: 最后执行
    - `lambda 函数直接给外部的对象重新赋值`__
.. __: lambda.rst


nonlocal
---------
    - **python3 新增**
    - 在函数或其他作用域中使用外层（非全局）变量

        .. code-block:: python

            i1, l1 = 0, [0]
            def outer():
                # nonlocal i1  #: SyntaxError
                # nonlocal l1  #: SyntaxError
                i2, l2 = 0, [0]
                def inner():
                    nonlocal i2, l2
                    i2 += 1
                    l2 += [1]
                    print(i1, l1, i2, l2)  #: 0 [0] 1 [0, 1]  #: 后执行
                print(i1, l1, i2, l2)      #: 0 [0] 0 [0]     #: 先执行
                return inner


global
------
    - 在局部对全局变量（不可变类型）修改

        .. code-block:: python

            i = j = 0
            def outer():
                print(i, j)      #: 0 0
                global i
                i += 1
                print(i, j)      #: 1 0
                def inner():
                    global i, j
                    i += 1
                    print(i, j)  #: 2 0
                return inner
            outer()()
            print(i, j)          #: 2 0  # 全局变量也随之改变
