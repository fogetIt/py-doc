递归
=====
- 函数调用自身
- 有出口（递归结束边界条件）
    - 边界条件不满足 **--->** 递归前进
    - 边界条件满足 **--->** 递归返回
        - 在问题的规模极小时必须 **直接给出解答** 而不再进行递归调用
    - 无边界条件的递归调用将会成为 **死循环** 而不能正常结束

:优点: 定义简单，逻辑清晰

    - 把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题
    - 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了代码量
:缺点:
    - 递归算法通常很简洁，但运行效率（相对常用的算法如普通循环等）较低
    - `栈溢出 <../内存管理/概述.rst>`_


-----

递归对于对象的定义是按照“先前定义的”同类对象来定义的。
::
例如：你怎样才能移动100个箱子？
答案：
    你首先移动一个箱子，并记下它移动到的位置，然后再去解决较小的问题：
        你怎样才能移动99个箱子？
            最终，你的问题将变为怎样移动一个箱子，而这是你已经知道该怎么做的。
如此的定义在数学中十分常见。
::
例如，集合论对自然数的正式定义是：1是一个自然数，每个自然数都有一个后继，这一个后继也是自然数。

-----


数学中的递归问题
--------------
- 德罗斯特效应
- 汉诺塔
- **64** 格的麦粒


尾递归
------
- 在函数返回的时候，调用自身本身。并且，**return** 语句不能包含表达式。
- 这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
- 遗憾的是，大多数编程语言没有针对尾递归做优化， **Python** 解释器也没有做优化。
