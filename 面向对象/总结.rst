面向对象
=======
    - 一种编程的思维方式：把事物的特性和功能用一个 **class** 包裹起来
    - **CPython** 为例：
        - 所有变量都是一个 **PyObject*** ，也就是指针
        - 所有赋值语句都是将一个对象的地址赋值给变量
        :可变对象: ``变量名 -> 容器 [-> 下级容器 ...] -> 值``
        :不可变对象:
            - ``变量名 -> 值``
            - 不可以对元素进行赋值
            - 不可以修改对象本身的内容
        - 容器（ ``list, dict`` 等）里面的元素也是对象


面向对象三大特征
--------------
    :继承:
        - 子类使用父类的方法、属性
        .. code-block:: python

            class Cls(object): pass
            class D(Cls): pass
            print(isinstance(d, D), isinstance(d, Cls)) #: (True, True)
            print(type(d) is D, type(d) is Cls)         #: (True, False)
    :多态:
        - 根据引用对象的不同表现不同的行为方式
        - 在运行时确定其状态，在编译阶段无法确定其类型
        - 鸭子类型
            - 动态语言调用实例方法，不检查类型，只要方法存在，参数正确，就可以调用
        - 子类可以重写，也可以不重写父类方法
        :“开闭”原则:
            - 新增一种子类时，只要确保方法编写正确，不用管原来的代码是如何调用的
            - 对扩展开放：允许新增子类
            - 对修改封闭：不需要修改依赖父类型的函数
    :封装:
        - 一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法
        - 把成员变量（类的属性）和成员函数（类的行为）封装在一起（在类中）的编程特性
        - 通过严格的接口控制，防止该类的代码和数据被外部类定义的代码随便访问的保护屏障


组合、派生
---------
    :组合:
        - 在类中引用其它的类
        - 当类之间有显著的不同，并且（较小的类）是较大的类所需要的组件时
    :派生: 相同的类但有一些不同的功能


继承顺序_
---------
    - 子类和父类存在相同的方法、属性时
        :覆盖: 子类优先使用自身的方法、属性
    - 父类找不到方法、属性，向父类的父类找
    - 在子类中通过类名调用父类的方法、属性，父类优先使用子类已有的方法、属性
.. _继承顺序: order.py


特殊变量_
--------
.. _特殊变量: ../起步/基础语法.rst/特殊变量


- 通过`instance._clsName__attr`来访问类的私有变量
    + 仅用于调试
    + 不同的解释器`_clsName__attr`会不同

##### ClsName.__mro__
- 基类查找顺序
    + 记录一个类的所有基类的类型序列
    + `super`机制里执行公共父类的顺序
        * 保证各个父类的函数被逐一调用，且每个公共父类仅被执行一次
        * 前提：每个类都要使用`super`
        * `super(Cls, self).func`不一定调用当前类的父类的`func`函数
    + e.g.
        ```
        (<class '__main__.F'>, ..., <type 'object'>)
        ```
- 混用`super`类和非绑定的函数
    + 可能导致应该调用的父类函数没有调用或者被调用多次
    + 要不全部用类名调用父类，要不就全部用`super`
- [使用`super`继承](../demo/super_demo.py)
    + 调用`super`类的初始化函数（简单记录了类类型和具体实例），产生一个`super`对象
    + 如果修改了父类名称，在子类不需要修改
    + 多继承时，不需要一一定义

##### [经典类/新式类](../demo/mixin_demo.py)
- 多继承
    + 通过多重继承，一个子类就可以同时获得多个父类的所有功能
    + 组合多个`MixIn`的功能，而不是设计多层次的复杂的继承关系
- 经典类
    + 是实例`<type 'classobj'>`
    + 搜索顺序：深度优先（尽量向上查找父级），从左至右
- 新式类
    + 是类型`<type 'type'>`
    + 搜索顺序：广度优先（尽量查找同胞兄弟），继承放在前面的
    + 调用`dir()`返回的属性更多