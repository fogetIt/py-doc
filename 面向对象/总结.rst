面向对象
=======
    - 一种编程的思维方式：把事物的特性和功能用一个 **class** 包裹起来
    - **CPython** 为例：
        - 所有变量都是一个 **PyObject*** ，也就是指针
        - 所有赋值语句都是将一个对象的地址赋值给变量
        :可变对象:   ``变量名 -> 容器 [-> 下级容器 ...] -> 值``
        :不可变对象: ``变量名 -> 值``

            - 不可以对元素进行赋值
            - 不可以修改对象本身的内容
        - 容器（ ``list, dict`` 等）里面的元素也是对象


面向对象三大特征
--------------
    :继承: 子类使用父类的方法、属性

        .. code-block:: python

            class Cls(object): pass
            class D(Cls): pass
            print(isinstance(d, D), isinstance(d, Cls))  #: (True, True)
            print(type(d) is D, type(d) is Cls)          #: (True, False)
    :多态: 根据引用对象的不同表现不同的行为方式

        - 在运行时确定其状态，在编译阶段无法确定其类型
        - 鸭子类型
            - 动态语言调用实例方法，不检查类型，只要方法存在，参数正确，就可以调用
        - 子类可以重写，也可以不重写父类方法
        :“开闭”原则:
            - 新增一种子类时，只要确保方法编写正确，不用管原来的代码是如何调用的
            - 对扩展开放：允许新增子类
            - 对修改封闭：不需要修改依赖父类型的函数
    :封装: 一种将抽象性函式接口的实作细节部份包装、隐藏起来的方法

        - 把成员变量（类的属性）和成员函数（类的行为）封装在一起（在类中）的编程特性
        - 通过严格的接口控制，防止该类的代码和数据被外部类定义的代码随便访问、修改
            - `特殊变量 <../起步/基础语法.rst>`_
            - 访问类的私有变量
                - ``instance._Cls__attr``
                    - 仅用于调试
                    - 不同的解释器 ``_Cls__attr`` 名称会不同


继承顺序_
---------
    - 子类和父类存在相同的方法、属性时
        :覆盖: 子类优先使用自身的方法、属性
    - 父类找不到方法、属性，向父类的父类找
    - 在子类中通过类名调用父类的方法、属性，父类优先使用子类已有的方法、属性
.. _继承顺序: order.py



Cls.__mro__
------------
    - 基类查找顺序
        - 记录一个类的所有基类的类型序列
        - **super** 机制里执行公共父类的顺序
            - 保证各个父类的函数被逐一调用，且每个公共父类仅被执行一次
            - 前提：每个类都要使用 **super**
            - ``super(Cls, self).func`` 不一定调用当前类的父类的 ``func`` 函数
            :e.g.: ``(<class '__main__.F'>, ..., <type 'object'>)``
    - 不要混用 **super** 和类名，调用非绑定的函数
        - 可能导致应该调用的父类函数没有调用或者被调用多次
    - `使用 super 继承 <super.py>`_
        - 调用 **super** 类的初始化函数（简单记录了类类型和具体实例），产生一个 **super** 对象
        - 如果修改了父类名称，在子类不需要修改
        - 多继承时，不需要一一定义


经典类/新式类
------------
    :派生: 相同的类但有一些不同的功能
    :组合: 在类中引用其它的类

        - 当类之间有显著的不同，并且（较小的类）是较大的类所需要的组件时
        - 多重继承
            - 一个子类就可以同时获得多个父类的所有功能
            - 组合多个 **MixIn** 的功能，而不是设计多层次的复杂的继承关系

    ========  =========================  ========
     -          经典类                      新式类
    ========  =========================  ========
    类型区别     是实例                      是类型
     -          ``<type 'classobj'>``      ``<type 'type'>``
    搜索顺序     深度优先，从左至右            广度优先，继承放在前面的
     -          尽量向上查找父级             尽量查找同胞兄弟
    ========  =========================  ========
