##### 类
- 一组用来描述如何生成一个对象的代码段
- (类)自身拥有创建对象(实例)的能力
- 类也是对象，可以在运行时动态地创建
    + 可以将它赋值给一个变量
    + 可以拷贝它
    + 可以为它增加属性
    + 可以将它作为函数参数进行传递
- python中通过一个标准的类定义来创建类：
    1. 收集所有属性到`__dict__`字典中
    2. 当类定义结束，`python`将决定类的元类
        - 元类(`metaclasses`)
            + 一个类的类，任何实例是它自己的类
            + 一个当创建类时改变Python类行为的有效方式
            + 元类 --> 类 --> 实例
            + `type`，`python`中所有类的默认元类
            + 一个类及其父类有`__metaclass__`属性者，即为此类的元类，否则`type`是其元类
    3. 实例化元类(创建类对象)：
    ```python
    # Meta(clsName, (baseCls, ...), {attr: value, ...})
    cls = type('A', (object), {"a": 1})
    ```

##### 类名后面括号内的参数，表明其继承的父类
##### 函数：必须调用执行
##### 类：可以自动执行

python可以自动给未知的变量，增加一个内部属性。

###### 实例化
- `class`创建内存对象的过程
    + 方法本身属于类，而数据由实例定义
    + 类函数比正常函数多一个额外的第一参数`self`（惯例）
        * 表示（调用时的）类的实例
        * 作用
            - 自动转化`instance.method(arg) -> Cls.method(instance, arg)`
- 使用实例访问实例方法时，方法是绑定的
- 使用类名访问实例方法时，方法是未绑定的
    + `<unbound method Cls.func>`
    + 可以这样`Cls.method(Cls(), *arg, **kwargs)`
- 当类属性`不可变时`
    + 实例可以访问类属性（如果实例没有同名属性）
    + 实例无法修改、覆盖类属性，只会创建同名实例属性
    + 实例删除的是同名实例属性（如果有的话）
- 当类属性`可变时`
    + 实例可以访问类属性（如果实例没有同名属性）
    + 实例可以修改、覆盖类属性
    + 实例无法删除类属性（除非实例重新定义了同名属性）
- 调用非绑定方法（比如：调用一个还没有任何实例的类中的方法）
    + 需要传递一个实例对象作为参数
        * e.g.
            ```python
            ClsName.__init__(self, *args, **kwargs)
            super(ClsName, self).__init__(*args, **kwargs)
            ```
- 类属性的修改会影响到所有的实例
    + e.g.
        ```python
        A.name = 'class name'
        A.func = lambda cls, x: x ** 2 
        ```
- 给实例绑定属性、方法，不会影响到类和其它实例
    + e.g.
        ```python
        from types import MethodType
        a = A()
        a.name = 'instance name'
        a.func = MethodType(lambda self, x: x ** 2, a)
        ```
