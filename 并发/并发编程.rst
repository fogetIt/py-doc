并发编程
-------
    .. image:: concurrent.png
    :process: 进程

        - 应用程序的一次执行实例
            - 程序没有生命，只有 **CPU** 赋予程序生命时，它才能成为一个活动的实体
            - 正常情况下 **避免在一台机器上同时运行同一应用程序的多个实例**
        - 包含上下文切换的程序执行时间总和
            - **CPU** 加载上下文 + **CPU** 执行 + **CPU** 保存上下文
        - 线程的容器，包含 **1~*** 个线程
        :thread: 线程

            - 进程的组成部分
                - 操作系统创建一个进程后，该进程会自动申请一个主线程
            - 共享了进程上下文环境，把进程的 **CPU** 分成更为细小的时间切片
                - 线程有自己的栈和栈指针、程序计数器、寄存器等
                - 线程之间互不影响，有开始、运行、结束三个状态
            - 缺点
                - 进程内部有线程数目的限制
                - 随着并发量的增加，线程生成和切换的成本也变得昂贵
            :coroutine: 协程

                - 一种用户态的轻量级线程（微线程、纤程）
                - 在 **1** 个线程中规定代码块执行顺序
                    - 协程拥有自己的寄存器上下文和栈
                        - 协程能保留上一次调用时的状态
                        - 协程调度切换时，将寄存器上下文和栈保存到其他地方
                        - 切回来时，恢复先前保存的寄存器上下文和栈
                        - 每次过程重入时，就相当于进入上一次调用的状态，进入上一次离开时所处逻辑流的位置
                    - 一个线程内可以同时存在多个协程，但是只有 **1** 个是激活的


:死锁: 由于 **2~*** 个执行单元之间相互等待对方结束而引起阻塞的情况


=================  =====================  ==========================  =====
 -                   进程                    **python** 线程             协程
=================  =====================  ==========================  =====
调度方式              抢占式                  抢占式                       协同式
调度者                操作系统                操作系统                     编程语言
资源分配              独立内存空间             共享所在进程资源               只需一块内存，记录之前调用的栈信息
通信（共享资源）       困难                    方便
切换/申请             开销大，效率差           开销小                       开销最小，效率最快（内存拷贝速度）
并发量                低                     高                          最大化高并发
线程安全              问题不易定位             问题不易定位                  没有安全问题
崩溃影响              不影响其它进程           会导致整个进程死掉
适用场景              ``重量级`` 任务          共享变量的 ``小任务``         **I/O** 操作特别多
=================  =====================  ==========================  =====
