并发编程
-------
    .. image:: 并发.png
    :process: 进程

        - 应用程序的一次执行实例
            - 程序没有生命，只有 **CPU** 赋予程序生命时，它才能成为一个活动的实体
            - 正常情况下 **避免在一台机器上同时运行同一应用程序的多个实例**
        - 包含上下文切换的程序执行时间总和
            - **CPU** 加载上下文 + **CPU** 执行 + **CPU** 保存上下文
        - 线程的容器，包含 **1~*** 个线程
        :thread: 线程

            - 进程的组成部分
                - 操作系统创建一个进程后，该进程会自动申请一个主线程
            - 共享了进程上下文环境，把进程的 **CPU** 分成更为细小的时间切片
                - 线程有自己的栈和栈指针、程序计数器、寄存器等
                - 线程之间互不影响，有开始、运行、结束三个状态
            - 缺点
                - 进程内部有线程数目的限制
                - 随着并发量的增加，线程生成和切换的成本也变得昂贵
            :coroutine: 协程

                - 一种用户态的轻量级线程（微线程、纤程）
                - 在 **1** 个线程中规定代码块执行顺序
                    - 协程拥有自己的寄存器上下文和栈
                        - 协程能保留上一次调用时的状态
                        - 协程调度切换时，将寄存器上下文和栈保存到其他地方
                        - 切回来时，恢复先前保存的寄存器上下文和栈
                        - 每次过程重入时，就相当于进入上一次调用的状态，进入上一次离开时所处逻辑流的位置
                    - 一个线程内可以同时存在多个协程，但是只有 **1** 个是激活的


=================  =====================  ==========================  =====
 -                   进程                    **python** 线程             协程
=================  =====================  ==========================  =====
调度方式              抢占式                  抢占式                       协同式
调度者                操作系统                操作系统                     编程语言
资源分配              独立内存空间             共享所在进程资源              只需一块内存，记录之前调用的栈信息
通信/共享资源         困难                    方便                         方便
切换/申请             开销大，效率差           开销小                       开销最小，效率最快（内存拷贝速度）
并发量                低                     高                           最大化高并发
线程安全              问题不易定位            问题不易定位                  没有安全问题
崩溃影响              不影响其它进程           会导致整个进程死掉
适用场景              ``重量级`` 任务         共享变量的 ``小任务``         **I/O** 操作特别多
=================  =====================  ==========================  =====


CPU 密集型程序 VS I/O 密集型程序
-----------------------------
    :I/O:
        - 程序的输入、输出，一般对应着硬盘、内存的读/写
        - ``time.sleep(n)`` ，可以模拟 **I/O** 阻塞
    :I/O 密集型程序:
        - 在硬盘、内存达到性能极限（速度）时， **CPU** 占用率仍然较低， **CPU** 在等待 **I/O**
        - 原因
            - 任务本身需要大量 **I/O** ，而 **pipeline** 做得不是很好，没有充分利用 **CPU**
            - 数据局部性不是很好，导致较多 **page error** ，产生了大量 **I/O** 开销
        - e.g.
            - **web server** 的静态页面访问
            - 基于数据库的一些应用
        :并发选择: ``多进程 + 协程`` 、 ``多进程 + 多线程``

            - 这种情况下，多线程可以明显提高效率
                - 比如，爬虫等待 socket 返回数据时可以执行其它代码
    :CPU 密集型程序: 计算密集型

        - **CPU** 占用很高， **I/O** 在很短的时间就可以完成
        - 原因
            - 程序大部份时间用来做计算、逻辑判断等 **CPU** 动作，不太需要访问 **I/O** 设备
            - 程序是多线程实现因此屏蔽掉了等待 **I/O** 的时间
        - e.g.
            - 一个计算圆周率至小数点一千位以下的程序（绝大部份时间用在三角函数和开根号的计算）
        :并发选择: ``多进程``

            - 这种情况下，多线程是鸡肋
                - 多个线程的代码很可能是线性执行的，因为有 ``context switch`` ，效率可能还不如单线程
    :判断:
        - 查看达到性能极限时的 **CPU** 占用率（ top ）
        - 查看具体的 **I/O** 操作或 **page error** 的统计数据（ sar, iostat ）
        - 查看更精准的信息，例如确定具体是哪些代码产生了这些开销（ oprofile, vtune ）
    - 如果在一个系统里 CPU 密集型程序和 I/O 密集型程序一起 run 会怎样？
        - 应该是 CPU 密集型程序对 CPU 的占用率会非常不公平地接近 100%
            - 因为 I/O 密集型程序可能一个时间片还没用完就阻塞了，放弃 CPU 了
            - 而 CPU 密集型程序因此而得到了很多调度机会，并且每次都能把 CPU run完
            - 故在这样的系统里要给 I/O 密集型程序更高的优先级使其能被调度得更多些
