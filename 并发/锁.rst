解释器全局锁
============

:``CPython G(lobal )I(nterpreter )L(ock)``:
    - 任何线程执行前，必须先获得 **GIL** ，其他的线程需要等待这个线程释放之后才可以访问
    - 每执行 **100** 条字节码，解释器就自动释放 **GIL** ，让别的线程有机会执行
    - 任意时间只有一个 **python** 解释器（进程）在解释字节码，多线程只能交替执行
        - 即使 ``线程数 <= CPU 核心数`` ，也只能用到 **1** 个核
        - 在 ``解释器级别`` 实现了对共享资源访问的互斥


锁
====
- 锁定 **执行单元** 之间的全局变量
    - 进程的内存是各自独立的
- `互斥（同步）锁`_
    - multiprocessing.Lock()
    - threading.Lock()
- `多重（递归）锁`_
    - multiprocessing.RLock()
    - threading.RLock()
- `信号量`_
    - multiprocessing.Semaphore(n)
    - threading.Semaphore(n):
- `绑定信号量`_
    - multiprocessing.BoundedSemaphore(n)
    - threading.BoundedSemaphore(n):
- `条件变量（关联锁）`_
    - multiprocessing.Condition()
    - threading.Condition()
- `事件`_
    - multiprocessing.Event()
    - threading.Event()


互斥（同步）锁
---------------

:应用场景:
    - 多进程修改共享数据
    - 多线程修改共享数据
        - **I/O** 密集型多线程任务
        - 一个线程复制数据与修改数据期间发生了阻塞，其它线程也复制修改了原数据

:acquire(): 申请锁
:release(): 释放锁

- 第一个  **执行单元** （进程/线程）申请到锁，会在执行公共数据的过程中持续阻塞后续  **执行单元**
- 后续  **执行单元** 只能等待第一个  **执行单元** 释放锁
- 当第一个  **执行单元** 将锁释放，后续的  **执行单元** 会进行争抢

:死锁:
    - 由于 **2~*** 个  **执行单元** 之间相互等待对方结束而引起阻塞的情况
        - 当有多个互斥锁对象存在的时候，可能会导致死锁


多重（递归）锁
----------------
- 锁对象可被同一线程多次 **acquire()/release()**
- 除了 ``locked, unlocked`` 状态外还记录了当前 **执行单元** 和递归层数
- **acquire()/release()** 必须成对出现
- 当 **release()** 次数等于 **acquire()** 次数时，释放锁


信号量
--------
- 限制线程的并发量
    - 每次允许指定数量的 **执行单元** 访问某段程，其它 **执行单元** 处于等待
    - 当并发量限制为 **1** 时，就相当于 ``RLock()``
- 管理一个内置的计数器

    :acquire(): 计数 -1

    - 计数 ==0 时，自动阻塞，等待 **release()**

    :release(): 计数 +1


绑定信号量
------------
- 在调用 **release()** 时，会检查增加的计数是否超过上限


条件变量（关联锁）
-------------------
- 在内部维护一个多重锁对象

:acquire()/release(): 含义同 **RLock()**
:wait([timeout]):     **release()** 锁对象，同时挂起 **执行单元**

    :适合场景: 队列为空或队列已满
:notify():     唤醒一个挂起的 **执行单元** （如果存在），但不会释放锁
:notify_all(): 唤醒所有挂起的 **执行单元** ，但不会释放锁


事件
--------
- 通过维护内部的标识符来实现 **执行单元** 间的同步
- 一个 **执行单元** 通知事件，其他 **执行单元** 等待事件

:wait([timeout]): 挂起 **执行单元** （直到标识符为 True 或超时，如果是守护线程，不会阻塞主线程）
:set():           标识符设为 True
:clear():         标识符设为 False
:isSet():         判断标识符
