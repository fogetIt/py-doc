:死锁: 由于 **2~*** 个执行单元之间相互等待对方结束而引起阻塞的情况

-----
:僵尸进程: 进程结束，线程没结束，线程不能自己释放空间，导致：

    - 内存无法释放，卡慢
    - 新的进程无法开始
-----

:线程安全问题: 多线程访问同一代码，是否会产生不确定的结果


=================  =====================  ==========================  =====
 -                   进程                    **python** 线程             协程
=================  =====================  ==========================  =====
调度方式              抢占式                  抢占式                       协同式
调度者                操作系统                操作系统                     编程语言
资源分配              独立内存空间             共享所在进程资源               只需一块内存，记录之前调用的栈信息
通信（共享资源）       困难                    方便
切换/申请             开销大，效率差           开销小                       开销最小，效率最快（内存拷贝速度）
并发量                低                     高                          最大化高并发
线程安全              问题不易定位             问题不易定位                  没有安全问题
崩溃影响              不影响其它进程           会导致整个进程死掉
适用场景              ``重量级`` 任务          共享变量的 ``小任务``         **I/O** 操作特别多
=================  =====================  ==========================  =====


解释器全局锁
-----------
    - Python GIL(Global Interpreter Lock)
    :python 伪线程:
        :定时器: 在 **1** 个进程内定时切换线程
        - 无法利用多核的优势
            - 任意时间只有一个 **python** 解释器（进程）在解释字节码
            - **CPython** 中，为了解决多线程间多份缓存数据一致性和状态同步的困难
                - 任何线程执行前，必须先获得 **GIL** ，其他的线程就需要等待这个线程释放之后才可以访问
                - 每执行 **100** 条字节码，解释器就自动释放 **GIL** ，让别的线程有机会执行
            - 实现了对共享资源访问的互斥，而且是非常霸道的 ``解释器级别的互斥``
        - 所以，多线程只能交替执行，即使 ``线程数 <= CPU 核心数`` ，也只能用到 **1** 个核
    :python 多进程: 能够利用多核优势，多个进程有各自独立的 **GIL**，互不影响
------

:I/O: 程序的输入、输出，一般对应着硬盘、内存的读/写


CPU 密集型程序 VS I/O 密集型程序
-----------------------------
    :I/O 密集型程序:
        - 在硬盘、内存达到性能极限（速度）时， **CPU** 占用率仍然较低， **CPU** 在等待 **I/O**
        - 原因
            - 任务本身需要大量 **I/O** ，而 **pipeline** 做得不是很好，没有充分利用 **CPU**
            - 数据局部性不是很好，导致较多 **page error** ，产生了大量 **I/O** 开销
        - e.g.
            - **web server** 的静态页面访问
            - 基于数据库的一些应用
        :并发选择: ``多进程 + 协程`` 、 ``多进程 + 多线程``

            - 这种情况下，多线程可以明显提高效率
                - 比如，爬虫等待 socket 返回数据时可以执行其它代码
    :CPU 密集型程序: 计算密集型

        - **CPU** 占用很高， **I/O** 在很短的时间就可以完成
        - 原因
            - 程序大部份时间用来做计算、逻辑判断等 **CPU** 动作，不太需要访问 **I/O** 设备
            - 程序是多线程实现因此屏蔽掉了等待 **I/O** 的时间
        - e.g.
            - 一个计算圆周率至小数点一千位以下的程序（绝大部份时间用在三角函数和开根号的计算）
        :并发选择: ``多进程``

            - 这种情况下，多线程是鸡肋
                - 多个线程的代码很可能是线性执行的，因为有 ``context switch`` ，效率可能还不如单线程
    :判断:
        - 查看达到性能极限时的 **CPU** 占用率（ top ）
        - 查看具体的 **I/O** 操作或 **page error** 的统计数据（ sar, iostat ）
        - 查看更精准的信息，例如确定具体是哪些代码产生了这些开销（ oprofile, vtune ）
    - 如果在一个系统里 CPU 密集型程序和 I/O 密集型程序一起 run 会怎样？
        - 应该是 CPU 密集型程序对 CPU 的占用率会非常不公平地接近 100%
            - 因为 I/O 密集型程序可能一个时间片还没用完就阻塞了，放弃 CPU 了
            - 而 CPU 密集型程序因此而得到了很多调度机会，并且每次都能把 CPU run完
            - 故在这样的系统里要给 I/O 密集型程序更高的优先级使其能被调度得更多些
