CPU 核心分配
=============
- 某一时间点 **1** 个 CPU 只能分配给 **1** 个进程

    :多核处理器:
        - 相当于多个 **CPU**
        - 同一时间点能运行多个进程

        :多核 VS 多U:

            - 同样的核心数
                - 成本低
                - 性能好
                - 主板设计简单
                - 功耗低
                - 体积小
                - 数据共享容易

    :超线程技术: 利用硬件指令，把两个逻辑内核模拟成两个物理芯片

- 一般情况下， **CPU** 远远快于寄存器、 **RAM** 和其它设备


:执行单元: 进程/线程
:共享数据安全问题: 多个 **执行单元** 访问同一数据空间，存在多份缓存数据一致性和状态同步的困难，会产生不确定的结果


CPU 调度方式
==============

:抢占式调度: 操作系统负责分配 **CPU** 时间给等待队列中的各个 **执行单元**

    :操作系统进程调度:
        - 一旦当前的进程使用完分配的 **CPU** 时间，发出一个信号
        - 操作系统响应这个信号，开始进程调度，运行下一个线程/进程
        - 所以任何一个线程都不能独占 **CPU**
        - 每个线程占用 **CPU** 的时间取决于进程和操作系统
    :**python** 线程调度: 在 **python** 中通过软件模拟（时钟）中断信号，来实现线程调度

:非抢占式调度: 某个 **执行单元** 需要多少 **CPU** 时间就占用多少 **CPU** 时间

    - 占用 **CPU** 的 **执行单元** 拥有对 **CPU** 的控制权
        - 只有它自己主动释放 **CPU** ，其他的 **执行单元** 才可以使用
    - 其他所有需要 **CPU** 的 **执行单元** 都可能“饿死”
    - 在处理机空闲，即该 **执行单元** 没有使用 **CPU** 时，系统可以允许其他的 **执行单元** 暂时使用 **CPU**


并发 VS 并行
=============

:并发: 总进程数 > **CPU** 数

    :时间片轮转进程调度: 物理 **CPU** 在若干程序之间多路复用

        - 在操作系统的管理下，所有正在运行的进程轮流使用 **CPU**
        - 每个进程允许占用 **CPU** 的时间非常短
            - 用户感觉不出 **CPU** 在轮流为多个进程服务
            - 所有进程好象都在不间断地运行一样

    - 对有限物理资源强制行使多用户共享以提高效率
:并行: 总进程数 <= **CPU** 数

    - 多个进程真正同时运行
    - 不同的进程分配给不同的 **CPU** 来运行

- 并行运行的效率显然高于并发运行，所以在多 **CPU** 的计算机中，多任务的效率比较高
- 但是，如果在多 **CPU** 计算机中只运行一个进程，就不能发挥多 **CPU** 的优势


python 并发方式
===================
.. image:: process.png

=================  =====================  ==========================  =====
 -                   进程                    **CPython** 线程            协程
=================  =====================  ==========================  =====
调度方式              抢占式                  抢占式                       协同式
调度者                操作系统                操作系统                     编程语言
资源分配              独立内存空间             共享所在进程资源               一块内存，记录之前调用的栈信息
通信（共享数据）       困难                    方便                         方便
 -                   问题不易定位             问题容易定位                  问题容易定位
切换/申请             开销大，效率差           开销小                       开销最小，效率最快（内存拷贝）
并发量                低                     较高                         最高
适用场景              ``CPU`` 密集            ``I/O`` 密集                ``I/O`` 密集
=================  =====================  ==========================  =====

:process: 进程

    - 应用程序的一次执行实例
        - 程序没有生命，只有 **CPU** 赋予程序生命时，它才能成为一个活动的实体
        - 正常情况下 **避免在一台机器上同时运行同一应用程序的多个实例**
    - 包含上下文切换的程序执行时间总和
        - **CPU** 加载上下文 + **CPU** 执行 + **CPU** 保存上下文
    - 线程的容器，包含 **1~*** 个线程
    - 能够利用多核优势，多个进程有各自独立的 **GIL** ，互不影响

    :thread: 线程

        - 进程的组成部分
            - 操作系统创建一个进程后，该进程会自动申请一个主线程
            - 一个进程中的各个线程与主线程共享同一片数据空间
        - 共享了进程上下文环境，把进程的 **CPU** 分成更为细小的时间切片
            - 线程有自己的栈和栈指针、程序计数器、寄存器等
            - 线程之间互不影响，有开始、运行、结束三个状态
        - 缺点
            - 进程内部有线程数目的限制
            - 随着并发量的增加，线程生成和切换的成本也变得昂贵

        :coroutine: 协程

            - 一种用户态的轻量级线程（微线程、纤程）
            - 在 **1** 个线程中规定代码块执行顺序
                - 协程拥有自己的寄存器上下文和栈
                    - 协程能保留上一次调用时的状态
                    - 协程调度切换时，将寄存器上下文和栈保存到其他地方
                    - 切回来时，恢复先前保存的寄存器上下文和栈
                    - 每次过程重入时，就相当于进入上一次调用的状态，进入上一次离开时所处逻辑流的位置
                - 一个线程内可以同时存在多个协程，但是只有 **1** 个是激活的


Process VS Thread
------------------
- Process 更稳定
- Process 对多核 CPU 的利用率更高
    - 使用进程池，可以跑满多核CPU
- Process 可以分布到多台机器上
    - Thread 只能利用到一个 CPU
- 使用多进程，一定要在非多进程的环境下先调试确认，多进程很多时候程序有问题，却不报错或者报的错误信息很难把握


CPU 密集型程序 VS I/O 密集型程序
-----------------------------
:I/O: 程序的输入、输出，一般对应着硬盘、内存的读/写
:I/O 密集型程序:

    - 在硬盘、内存达到性能极限（速度）时， **CPU** 占用率仍然较低， **CPU** 在等待 **I/O**
    - 原因
        - 任务本身需要大量 **I/O** ，而 **pipeline** 做得不是很好，没有充分利用 **CPU**
        - 数据局部性不是很好，导致较多 **page error** ，产生了大量 **I/O** 开销
    - e.g.
        - **web server** 的静态页面访问
        - 基于数据库的一些应用

    :并发选择: ``多进程 + 协程`` 、 ``多进程 + 多线程``

        - 这种情况下，多线程可以明显提高效率
            - 比如，爬虫等待 socket 返回数据时可以执行其它代码

:CPU 密集型程序: 计算密集型

    - **CPU** 占用很高， **I/O** 在很短的时间就可以完成
    - 原因
        - 程序大部份时间用来做计算、逻辑判断等 **CPU** 动作，不太需要访问 **I/O** 设备
        - 程序是多线程实现因此屏蔽掉了等待 **I/O** 的时间
    - e.g.
        - 一个计算圆周率至小数点一千位以下的程序（绝大部份时间用在三角函数和开根号的计算）

    :并发选择: ``多进程``

        - 这种情况下，多线程是鸡肋
            - 多个线程的代码很可能是线性执行的，因为有 ``context switch`` ，效率可能还不如单线程

:判断:

    - 查看达到性能极限时的 **CPU** 占用率（ top ）
    - 查看具体的 **I/O** 操作或 **page error** 的统计数据（ sar, iostat ）
    - 查看更精准的信息，例如确定具体是哪些代码产生了这些开销（ oprofile, vtune ）

- 如果在一个系统里 CPU 密集型程序和 I/O 密集型程序一起运行会怎样？
    - 应该是 CPU 密集型程序对 CPU 的占用率会非常不公平地接近 100%
        - 因为 I/O 密集型程序可能一个时间片还没用完就阻塞了，放弃 CPU 了
        - 而 CPU 密集型程序因此而得到了很多调度机会，并且每次都能把 CPU 用完
        - 故在这样的系统里要给 I/O 密集型程序更高的优先级使其能被调度得更多些
