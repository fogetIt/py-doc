python 伪线程/定时器
===================
    - **CPython** 由于 `解释器全局锁`_ ，线程在 **1** 个进程内定时切换
        - 所以无法利用多核的优势
        - 所以更适合 **I/O** 密集型应用
        .. _解释器全局锁:
        :解释器全局锁: ``CPython G(lobal )I(nterpreter )L(ock)``


线程安全问题
-----------
    - 一个进程中的各个线程与主进程共享同一片数据空间
    - 多线程访问同一数据空间，存在多份缓存数据一致性和状态同步的困难，会产生不确定的结果
    :解决:
        :CPython G(lobal )I(nterpreter )L(ock):
            - 任何线程执行前，必须先获得 **GIL** ，其他的线程就需要等待这个线程释放之后才可以访问
            - 每执行 **100** 条字节码，解释器就自动释放 **GIL** ，让别的线程有机会执行
            - 任意时间只有一个 **python** 解释器（进程）在解释字节码
                - 多线程只能交替执行，即使 ``线程数 <= CPU 核心数`` ，也只能用到 **1** 个核
                - 在 ``解释器级别`` 实现了对共享资源访问的互斥
        :threading.Lock():
            - 互斥锁/同步锁
                - **IO** 密集型多线程，一个线程复制数据与修改数据期间发生了阻塞，其它线程也复制修改了原数据
                - 第一个线程 **acquire()** 申请到锁，会在执行公共数据的过程中持续阻塞后续线程
                - 后续线程依次只能等待第一个线程 **release()** 释放锁
                - 当第一个线程将锁释放，后续的线程会进行争抢
            :死锁:
                - 由于 **2~*** 个执行单元之间相互等待对方结束而引起阻塞的情况
                - 当有多个互斥锁对象存在的时候，可能会导致死锁
        :threading.RLock():
            - 多重锁/递归锁
                - 除了 ``locked, unlocked`` 状态外还记录了当前线程和递归层数
                    - 锁对象可被同一线程多次 **acquire()** 和 **release()**
                - **acquire()** 和 **release()** 必须成对出现
                - 当 **release()** 次数等于 **acquire()** 次数时，释放锁
        :threading.Semaphore(n):
            - 信号量
                - 限制线程的并发量
                    - 并发量限制为 **1** 时，就相当于 ``threading.RLock()``
                    - 每次允许指定数量的线程访问某段程，其它线程处于等待
                - 管理一个内置的计数器
                    - 调用 **acquire()** 时，计数 -1
                    - 计数 ==0 时，自动阻塞，等待 **release()**
                    - 调用 **release()** 时，计数 +1
        :threading.BoundedSemaphore(n): 在调用 **release()** 时，会检查增加的计数是否超过上限
        :threading.Condition():
            - 条件变量/关联锁
                - 在内部维护一个多重锁对象
                    - **acquire(), release()** ，含义同 **RLock()**
                    - **wait([timeout])** ， **release()** 锁对象，同时挂起线程
                        - 适合场景：队列为空或队列已满
                    - **notify()** ，唤醒一个挂起的线程（如果存在），但不会释放锁
                    - **notify_all()** ，唤醒所有挂起的线，但不会释放锁
        :threading.Event():
            - 事件
                - 通过维护内部的标识符来实现线程间的同步
                - 一个线程通知事件，其他线程等待事件
                - **Event()** 没有锁，无法使线程同步阻塞
                - **wait([timeout])** ，挂起线程（直到标识符为 True 或超时）
                - **set()** ，标识位设为 Ture
                - **clear()** ，标识位设为 False
                - **.isSet()** ，判断标识位
        :threading.Timer(seconds, func):
            - 异步阻塞一段时间，后面的代码会不间断执行
            - time.sleep(n) ，同步阻塞


对象的线程安全
-------------
    :模块: python 模块是线程安全的，一个模块只会被实例化一次
    :容器:
        - 容器对象，只要保证唯一性（ id 相同，比如直接赋值），就是线程安全的
            - **类对象** ，在多线程下释放不完全，没释放的那部分内存，可以重复利用
            - **类的单例对象** ，在多线程下可以保证唯一性
        - 容器内部最内层的原子对象，不是线程安全的
        - 共享的容器对象，不能覆盖赋值
    - 可以修改的共享数据，尽量用锁来保护
