守护线程
-------
    - 别名叫做 **服务线程** ，在没有需要它服务的其他线程之后会自杀
        - 优先级很低，在后台运行l
        - 所以垃圾回收的线程也是一个守护线程
    :API:
        :setDaemon():        声明（非守护）子线程（在 **start()** 之前设置）
        :setDaemon(True):    声明（守护）子线程（在 **start()** 之前设置）
        :start():            开始执行线程函数（或者调用线程对象中的 **run()** ）
        :join(timeout=None): 阻塞父线程，直到完成运行、异常或超时（在 ``所有线程`` **start()** 之后设置）
    :模式:
        :setDaemon(False):           主线程杀掉子线程，强制退出（ **_thread** 模块就是这种模式）
        :setDaemon(False) + join(n): 主线程等待子线程，完成才退出
        :setDaemon():                主线程不等待子线程，主线程退出后，子线程也被杀掉
        :setDaemon() + join(n):      主线程不等待子线程，主线程退出后，子线程超时退出


线程全局变量
-----------
    - 用于管理线程相关的数据
        - 共享全局变量需要加锁
        - 局部变量传递麻烦
    :threading.local()/_thread._local():
        - 在线程中定义，可以绑定变量
        - 只在该线程中为全局变量
        - 对于其他线程来说是局部变量，不可更改
    - Flask 底层 Werkzeug 的 LocalStack ，就是基于线程全局变量，每个线程处理一个 HTTP 请求


僵尸进程
-------
    - 进程结束，线程没结束，线程不能自己释放空间，导致：
        - 内存无法释放
        - 新的进程无法开始


multiprocessing.dummy
----------------------
    - 精确克隆了 **mulprocessing** 的 **API** （线程版）
    - 可以方便地切换并发/并行
    :Pool:
        - 线程池
            :Pool().map(func, iterable): 将序列分配到不同线程上，分别执行函数
