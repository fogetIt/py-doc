生成器
=====
    :一种特殊的迭代器:
        - 不需要实现 ``__iter__(), __next__()`` 方法
        - 只需要一个 **yiled** 关键字


生成器推导式
-----------
    .. code-block:: python

        g = (i ** 2 for i in range(5)); print(g)  #: <generator object ... at ...>


生成器一定是迭代器，反之不成立
--------------------------
    .. code-block:: python

        g = (i ** 2 for i in range(5))
        print(g.__next__())    #: 0              #: 拥有 __next__()
        print(list(g))         #: [1, 4, 9, 16]
        print([i for i in g])  #: []             #: 只能迭代一次

        fg = lambda: (i ** 2 for i in range(5))
        print([i for i in fg()])  #: [0, 1, 4, 9, 16]
        print(list(fg()))         #: [0, 1, 4, 9, 16]  #: 使用函数，反复生成



------
    * 特性
        - 惰性计算的序列；
        - 当序列长度很大时，可以减少内存消耗（每次只需要记录一个值）；
        - 迭代器是`一次性`消耗品，使用完了以后就空了；
        - 无法通过直接赋值的形式把迭代器保存起来，需要使用copy.deepcopy；
    * 方法
        - iterator.next()、next(iterator, default)；
            + 每次调用时，使用上一次所保留下的参数，执行下一次的迭代（计算出下一个元素的值）；
            + 直到最后一个元素，没有元素时，抛出StopIteration；
        - for循环；

生成器（generator）通过 yield 语句快速生成迭代器————生成器都是Iterator；



列表、列表推导————整个列表一次性加载于内存之中（内存占用高）
#### 可迭代对象iterable————可用for循环迭代（无论有无下标）的（容器）对象
- 方法
    + for循环————调用iter()把Iterable变成Iterator再进行循环迭代；
    + dict迭代的是key，如果要迭代value，可以用for value in d.values()；
- 包含
    + 内置数据类型（str、list、tuple、dict、set）；


### 生成器
- 创建generator后，基本上不会调用next()，而是通过for循环迭代，并且不需要关心StopIteration错误；
- 除非面对非常大的列表，否则生成器与普通序列看不出明显的区别，但是应该尽量使用generator；
- 生成器表达式————生成一个生成器对象，一次加载一个列表元素（内存占用低）————`保存的是算法`
    + 生成器表达式————语法结构同列表推导式
    + (输出((满足断言表达式的)序列成员变量)表达式   for循环(输入序列)   [断言表达式])

### Iterator惰性计算
Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。

Iterator可以表示一个无限大的数据流，例如全体自然数。