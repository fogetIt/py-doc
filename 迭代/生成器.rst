生成器
=====
    :一种特殊的迭代器: **惰性计算** 的序列

        :生成器方法调用:

            - 调用时不会立即执行
            - 需要调用 **__next__()** 或者使用 **for** 循环来执行
                - 每次调用时，使用上一次所保留的参数，执行下一次的计算
                - 执行到 yield_ xxx 时，函数就返回下一个元素的迭代值
                - 直到最后一个元素，没有元素时，抛出 **StopIteration**
                    - `使用 for 循环不用处理 StopIteration <迭代器2.rst>`_
        - 不能提前知道序列的长度
        - 可以表示一个无限大的数据流，例如全体自然数
    - `生成器推导式 <推导式.rst>`_
    ========  ===========  ==========
     -          普通序列      生成器对象
    ========  ===========  ==========
    保存内容     整个列表      算法和当前迭代位置
    内存占用     高           低
    ========  ===========  ==========
        - 除非序列非常大，否则生成器与普通序列（列表、列表推导式...）看不出明显的区别
        - 但是应该尽量使用 generator


生成器一定是迭代器，反之不成立
--------------------------
    .. code-block:: python

        g = (i ** 2 for i in range(5))
        print(g.__next__())    #: 0              #: 拥有 __next__()
        print(list(g))         #: [1, 4, 9, 16]
        print([i for i in g])  #: []             #: 只能迭代一次

        fg = lambda: (i ** 2 for i in range(5))
        print([i for i in fg()])  #: [0, 1, 4, 9, 16]
        print(list(fg()))         #: [0, 1, 4, 9, 16]  #: 使用函数，反复生成


yield
------
    - 把一个函数变成一个生成器
        - 不需要自己实现 ``__iter__(), __next__()``
